<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1.0">
	<title>Lights On</title>
	<style>
		body {
			background-color: rgb(8,8,8);
			margin: 0;
			padding:0;
			display:block;
		}
		main{
			width:100%;
			height:600px;
			display:flex;
			justify-content: center;
			gap:10px;
			margin-top: 40px;
			margin-bottom: 40px;
			margin-right: 200px;

		}
		header{
			display: flex;
			justify-content: space-between;
			position: fixed;
			top: 0;
			left: 0;
			width:100%;
			height: 40px;
			/*padding: 0 0;*/
		}
		footer{
			display:flex;
			width: 100%;
			height: 40px;
			position: fixed;
			bottom: 0;
			background-color: lightyellow;
			justify-content: space-around;
		}
		.cellContainer {
			display: grid;
			grid-template-columns: repeat(var(--cols), 1fr);
			align-items: center;
			justify-items: center;
			justify-content: center;
			gap: 0px;
			aspect-ratio: 1/1;
			border-color:black;
			border-width: 4px;
			border-style:outset;
		}
		.cell {
			width: 100%;
			min-width: 10px;
			font-size: 18px;
			color: black;
			justify-content: center;
			align-items: center;
			cursor: pointer;
			aspect-ratio: 1/1;
			border-width: 3px;
			border-color: black;
		}
		#victoryLabel {
			font-size: 100px;
			background-color: rgb(11, 179, 5);
			position: fixed;
			top: 40px;
			left: 0;
			width: 100%;
			border-style: groove;
			border-color: rgb(208, 255, 0);
			border-width: 6px;
			text-align: center;
			justify-content: center;
			z-index: 100;
			display: none;
		}
		#victoryLabel[data-status="won"] {display: flex;}
		aside {
			width: 200px;
			position: fixed;
			top: 40px;
			right: 0px;
			bottom: 40px;
		}
		#solutionContainer {
			width: 100%;
			height: 100%;
			display: flex;
		}
		.editModeContainer {
			display: flex;
			align-items: center;
			justify-content: end;
			font-size: 24px;
			color: yellowgreen;
			font-family: sans-serif;
		}
		#editModeCheckbox {
			width: 20px;
			height: 20px;
		}
		#shuffleButton {
			width: 100%;
			height: 100%;
			font-size: 30px;
			background-color: darkgrey;
		}
		#solutionButton {
			width: 200px;
			font-size: 25px;
			color: red;
			background-color: black;
			border-color: orange;
		}
		#solutionLabel {
			visibility: hidden;
			font-size: 25px;
			font-family: sans-serif;
			color: rgb(255, 0, 0);
			align-content: center;
			text-align: center;
			height: 100%;
			width:100%;
		}
		.difficulty-dropdown {display: inline-block;}
		.difficulty-button {
			color: black;
			width: 200px;
			height: 100%;
			font-size: 25px;
			background-color: darkgrey;
		}
		.difficulty-list {
			display: none;
			position: absolute;
			width: 200px;
			z-index: 100;
		}
		.difficulty-list-button {
			display: block;
			width: 100%;
			background-color: rgb(255, 251, 251);
			color: black;
			text-decoration: none;
			font-size: 16px;
		}
		.shown {display: block;}
		.difficulty-list-button:hover {background-color: grey;	}
	</style>
</head>

<body>
	<header>
		<div class="difficulty-dropdown">
			<button class="difficulty-button" onclick="toggleDropdownList()">Grid size ▼</button>
			<div class="difficulty-list" id="difficulty-list"></div>
		</div>
		<label class="editModeContainer">
				<div>Edit mode</div>
				<input type="checkbox" id="editModeCheckbox">
		</label>
	</header>		
	<main >
		<div class="cellContainer" id="cellContainer"></div>
		<div class="cellContainer" id="solutionViewer"></div>
	</main>
	<div id="victoryLabel">CONGRATULATIONS!</div>
	<aside>
		<div id="solutionContainer">
			<div id="solutionLabel"></div>
		</div>
	</aside>
	<footer>
		<input type="button" id="shuffleButton" onclick="shuffleMainGrid(), checkVictory()" value="Shuffle">
		<input type="button" id="solutionButton" onclick="solveIt()" value="Solve it for me!">
	</footer>

	<script>
		const mainGridContainer = document.getElementById('cellContainer');
		const solutionGridContainer = document.getElementById('solutionViewer');
		const victoryLabel = document.getElementById('victoryLabel');
		const editModeCheckbox = document.getElementById('editModeCheckbox');
		const solutionLabel = document.getElementById("solutionLabel");
		const shuffleButton = document.getElementById('shuffleButton');
		const difficultyList = document.getElementById("difficulty-list");
		const mainGridCellButtonList = [];
		const solutionGridCellButtonList = [];

		function checkVictory() {
			let hasWon = true;

			if(Solution.selected==null) return;

			for (let cell of mainGridCellButtonList) {
				if (cell.status != Solution.selected.mat.value[cell.i][cell.j]) { hasWon = false; break; }
			}
			victoryLabel.dataset.status = (hasWon ? "won" : "none");
			
			if(hasWon && !window.speechSynthesis.speaking){
				const utterA = new SpeechSynthesisUtterance("ブラヴォ。メセドラシヤス！");
				utterA.lang="ja-JP";
				utterA.pitch=.5;

				const utterB = new SpeechSynthesisUtterance("ウィ、サプ。サプヴレマン僕。メセボン！");
				utterB.lang="ja-JP";
				utterB.pitch=1.9;
				
				utterB.addEventListener("end",()=>{victoryLabel.dataset.status = "none";});

				window.speechSynthesis.speak(utterA);
				window.speechSynthesis.speak(utterB);
			}
		}

		function solveIt() {
			/* 	the idea is : finalState = initialState + transitionMatrix∙pushedCells
				(notation change)	   f = i + A∙X
							   A⁻¹·(f-i) = A⁻¹·A·X
									   X = inv(A)·(f-i)
			*/

			if(Solution.selected==null) return;

			let inputMatrix = new Matrix(Array.from({length:mainGridCellButtonList.length},(_,i)=>[mainGridCellButtonList[i].status?1:0]));
			let finalMatrix = Solution.selected.mat;
			// on F2 : a-b = a+b
			let gridSize = finalMatrix.rows() ; // get size from where ? maingrid, solutiongrid, sqrt(maingridcelllist.length) ?
			let sol = Matrix.getTransitionMatrixFor(gridSize,gridSize).getInverseMatrix().multiplyMatrix(inputMatrix.addMatrix(finalMatrix.getColonized()));
			// no need to resquare sol
			solutionLabel.innerHTML = sol.value.map((v, i) => (v[0] == 1 ? mainGridCellButtonList[i].letter : '')).filter((c) => c != '').join(' ');
			solutionLabel.style.visibility = 'visible';
		}

		function shuffleMainGrid() {
			solutionLabel.style.visibility = 'hidden';
			victoryLabel.dataset.status = "shuffling";
			mainGridCellButtonList.forEach((cell) => {
				if (Math.random() > 0.5) cell.changeCellStatus();
			});
		}

		function toggleDropdownList() { difficultyList.classList.toggle("shown"); }

		function onClickMainGridButton(button) {
			if (button == null || !(button instanceof CellButton)) return;
			let editMode = editModeCheckbox.checked;
			if (editMode) { button.changeCellStatus(); }
			else
				mainGridCellButtonList.forEach((cell, index) => {
					let dx = Math.abs(cell.i - button.i);
					let dy = Math.abs(cell.j - button.j);
					if (dx + dy < 2 && !editMode) { cell.changeCellStatus(); }
				});
			checkVictory();
		}

		function onClickSolutionGridButton(button) {
			if(button==null || !(button instanceof CellButton)) return;
			if(editModeCheckbox.checked){
				Solution.selected.mat.value[button.i][button.j]=(Solution.selected.mat.value[button.i][button.j]+1)%2;
				button.changeCellStatus();
			}
			checkVictory();// in cas we won by editing the solution
		}

		class CellButton {
			status = false;
			// unsafe to keep them public and modifiable but osef
			button = null;
			letter = "none";
			i = -1;
			j = -1;
			color_ON = "rgb(200,200,40)";
			color_OFF = "rgb(50,50,00)";

			constructor(letter, i, j, callback) {
				this.letter = letter;
				this.i = i;
				this.j = j;
				this.button = document.createElement('button');
				this.button.classList.add("cell");
				this.button.textContent = letter;
				this.button.addEventListener('click', () => callback(this));
				this.changeCellStatus(false); // to update to false's color <-- could be outside too
				// think about it :
				//attachTo(list)=>list.appenchild(this.button);
				//detach()=>this.button.remove()
			}

			changeCellStatus(newStatus) { // swap if no argument
				if (newStatus == null || newStatus == undefined) this.status = !this.status;
				else this.status = newStatus;

				this.button.style.backgroundColor = (this.status ? this.color_ON : this.color_OFF);
				this.button.style.borderStyle = this.status?"outset":"inset";
			}
		}

		class Matrix {
			value = [];
			constructor(value) { this.value = value; } // you let value unverified ? REALLY ?
			static zeros(rows, cols = rows) { return new Matrix(Array.from({ length: rows }, () => Array.from({ length: cols }, () => 0))); }
			static ones(rows, cols = rows) { return new Matrix(Array.from({ length: rows }, () => Array.from({ length: cols }, () => 1))); }
			rows() { return this.value.length; }
			cols() { return this.value[0].length; }
			toString() {
				if (this.value == null) return "value is null WTF?!";
				else return this.value.map((row) => row.join(' ')).join('\n');
			}

			getColonized() { return new Matrix(this.value.flat().map((u) => [u])); }

			getInverseMatrix() {
				let rows = this.rows();
				let cols = this.cols();
				if (rows != cols || rows * cols == 0) throw new Error("cant reverse non square matrix!");
				//Array.from(objet_iterable,(val,index)=>{})
				//Array.from({length:9},(val,index)=>{}) // {length:9} is an object with only one attribute : length=9
				//Array.from(objet_iterable,(_,index)=>{})
				//Array.from("ABSDCEF",(_,index)=>0) // array of seven 0 
				// ()=>{} needs a return : Array.from({length:3},(_,i)=>{return i*i})
				// 		while ()=>5 doesnt

				// ...value is a spread operator : decompose in its elements
				// map creates a new array by applying a function to all its elements
				// myarray.map( (element,index,array)=>{/*do something and returns it}
				// const square = myarray.map((n,i)=>{return n*n;})

				// building expended matrix = [mat eye]
				//const M=Array.from({length:rows},(tab,i)=>{mat[i].concat([-1,-2-3])});
				//let p = .concat([-1,-2-3]

				// array.foreach return undefined
				// array.map     return a new array

				const M = this.value.map((row, i) => {
					const end = Array.from({ length: rows }, (_, j) => (i == j) ? 1 : 0);
					return [...row, ...end];
				});

				for (let c = 0; c < cols; c++) {
					if (M[c][c] == 0) {
						for (let r = c + 1; r < rows; r++) {
							if (M[r][c] == 1) {
								for (let col = 0; col < M[0].length; col++) M[c][col] = (M[c][col] + M[r][col]) % 2;
								break;
							}
						}
					}

					if (M[c][c] != 1) {throw new Error(`we couldnt fix the diag element (${c},${c}) : no usefull 1 below it ${M}`);}

					for (let line = 0; line < rows; line++) {
						if (line == c) continue; //skip the diag line
						if (M[line][c] != 0) {
							for (let col = 0; col < M[0].length; col++) M[line][col] = (M[line][col] + M[c][col]) % 2;
						}
					}
				}

				// array.slice(startindex,cutting end endindex opt)
				return new Matrix(M.map((row) => row.slice(rows)));
			}

			addMatrix(b) {
				if (b == null) throw new Error("cant ad null matrix");
				if (this.cols() != b.cols() || this.rows() != b.rows()) throw new Error(`cant add matrices (${this.rows()},${this.cols()})+(${b.rows()},${b.cols()})`);
				let result = Matrix.zeros(this.rows(), this.cols());
				for (let r = 0; r < result.rows(); r++) {
					for (let c = 0; c < result.cols(); c++) {
						result.value[r][c] = (this.value[r][c] + b.value[r][c]) % 2;
					}
				}
				return result;
			}
			multiplyMatrix(b) {
				if (b == null) throw new Error("cant multiply null matrix");
				if (this.cols() != b.rows()) throw new Error(`cant multiply matrices (${this.rows()},${this.cols()})×(${b.rows()},${b.cols()})`);

				let rows = this.rows();
				let cols = b.cols();
				let result = Matrix.zeros(rows, cols);
				for (let l = 0; l < rows; l++) {
					for (let c = 0; c < cols; c++) {
						for (let i = 0; i < this.cols(); i++) result.value[l][c] = result.value[l][c] + this.value[l][i] * b.value[i][c];
						result.value[l][c] = (result.value[l][c]) % 2;
					}
				}
				return result;
			}

			static getTransitionMatrixFor(gridSizeX, gridSizeY = gridSizeX) {
				if (gridSizeX != gridSizeY) throw new Error("cant init non squarre trans mat");
				let m=Matrix.zeros(gridSizeX*gridSizeY,gridSizeX*gridSizeY);
				for (let x = 0; x < gridSizeX; x++)
					for (let y = 0; y < gridSizeY; y++)
						for (let i = 0; i < gridSizeX; i++)
							for (let j = 0; j < gridSizeY; j++) {
								let Dx=Math.abs(x-i);
								let Dy=Math.abs(y-j);
								if (Dx + Dy < 2) m.value[x + gridSizeY * (y)][i + gridSizeX * (j)] += 1;
							}
				return m;
			}
		}

		function buildMainGrid(gridRows,gridCols=gridRows) {
			gridRows= gridRows ?? Solution.selected.mat.rows();
			gridCols= gridCols ?? Solution.selected.mat.cols();
			//initializeTransitionMatrixFor(gridRows,gridCols); // pertinent here in buildGrid ?

			// first remove the buttons then clean the array
			mainGridCellButtonList.forEach((c) => { c.button.remove() });
			mainGridCellButtonList.length = 0;
			mainGridContainer.style.setProperty('--cols', gridRows);
			// if width .... setProperty() ?

			for (let j = 0; j < gridCols; j++) {
				for (let i = 0; i < gridRows; i++) {
					let letter = i + j * gridRows + 1;
					let cell = new CellButton(letter, j, i, onClickMainGridButton);//reversed to be consistent with matrix indexing
					
					if (Math.random() > 0.5) cell.changeCellStatus();
					mainGridCellButtonList.push(cell);
					mainGridContainer.appendChild(cell.button);
				}
			}
		}

		function buildSolutionGrid(gridRows,gridCols=gridRows) {
			gridRows= gridRows ?? Solution.selected.mat.rows();
			gridCols= gridCols ?? Solution.selected.mat.cols();
			solutionGridCellButtonList.forEach((c) => { c.button.remove() });
			solutionGridCellButtonList.length = 0;
			solutionGridContainer.style.setProperty('--cols', gridRows);
			// if width .... setProperty() ?
			for (let j = 0; j < gridCols; j++) {
				for (let i = 0; i < gridRows; i++) {
					let letter = i + j * gridRows + 1;
					let cell=new CellButton(letter,j,i,onClickSolutionGridButton);//reversed to be consistent with matrix indexing
					cell.changeCellStatus((Solution.selected.mat.value[j][i]==1));
					solutionGridCellButtonList.push(cell);
					solutionGridContainer.appendChild(cell.button);
				}
			}
		}



/*
rethink the indexing of buttons
*/

		class Solution{
			mat=null;
			button=null;
			static selected=null;

			constructor(txt,mat){
				this.mat=mat;
				let element = document.createElement('button');
				element.classList.add('difficulty-list-button');
				element.textContent = txt;
				element.addEventListener('click', ()=>this.onClick() );
				difficultyList.appendChild(element);
			};

			onClick(){
				solutionLabel.style.visibility = 'hidden';
				victoryLabel.dataset.status = "shuffling";
				toggleDropdownList();
				Solution.selected = this;
				buildMainGrid();
				buildSolutionGrid();
				checkVictory(); // in case the new game is won at the beginning
			}

		}

		const solutions=[
			new Solution("1×1", Matrix.ones(1)),
			new Solution("3×3", Matrix.ones(3)),
			new Solution("3×3 corners", new Matrix([[1, 0, 1],[0, 0, 0],[1, 0, 1],])),
			new Solution("6×6", Matrix.ones(6)),
			new Solution("10×10", Matrix.ones(10)),
			//new Solution("15×15", Matrix.ones(15)) // too big
		];

		Solution.selected=solutions[1];

		/*document.addEventListener('click',()=>{
			difficultyList.classList.remove("shown");
		});*/

		// may just do as a click on a difficultyListButton ? solutions..
		//solutions[2][1].button.clik ?
		buildMainGrid();
		buildSolutionGrid();
	</script>
</body>

</html>